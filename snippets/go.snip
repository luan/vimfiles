snippet     fum
abbr        func (...) ...() { ... }
options     head
  func (${2:this} ${1:type}) ${3:fname}(${4}) ${5:error }{
    ${0:TARGET:return}
  }

snippet     func
abbr        func ...() { ... }
options     head
  func ${1:fname}(${2}) ${3:error }{
    ${0:TARGET:return}
  }

snippet     afun
abbr        func () { ... }
options     word
  func(${1}) ${2}{
    ${0:TARGET:return }
  }

# shorthand variable declaration
snippet va
  ${1} := ${2}
# variable initialization
snippet vr
  var ${1:t} ${0:string}
# variable declaration
snippet var
  var ${1} ${2}
# variables declaration
snippet vars
  var (
    ${1} ${2}
  )
# append
snippet ap
  ${1:slice} = append($1, ${2:value})${0}
# bool
snippet bl
  bool
# byte
snippet bt
  byte
# break
snippet br
  break
# channel
snippet ch
  chan ${0:int}
# case
snippet cs
  case ${1:value}:
    ${0}
# constants with iota
snippet co
  const (
    ${1:NAME1} = iota
    ${0:NAME2}
  )
# continue
snippet cn
  continue
# defer
snippet df
  defer ${0:func}()
# defer recover
snippet dfr
  defer func() {
    if err := recover(); err != nil {
      ${0:TARGET}
    }
  }()
# gpl
snippet gpl
  /*
   * This program is free software; you can redistribute it and/or modify
   * it under the terms of the GNU General Public License as published by
   * the Free Software Foundation; either version 2 of the License, or
   * (at your option) any later version.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with this program; if not, see <http://www.gnu.org/licenses/>.
   *
   * Copyright (C) ${1:Author}, `strftime("%Y")`
   */

  ${0}
# import
snippet im
  import (
    "${1:package}"
  )
# interface
snippet in
  interface{}
# full interface snippet
snippet inf
  interface ${1:name} {
    ${2:/* methods */}
  }
# if condition
snippet if
  if ${1:/* condition */} {
    ${0:TARGET}
  }
# else snippet
snippet el
  else {
    ${1}
  }
# error snippet
snippet ir
  if err != nil {
    return err
  }
  ${0}
# fallthrough
snippet ft
  fallthrough
# float
snippet fl
  float32
# float32
snippet f3
  float32
# float64
snippet f6
  float64
# if else
snippet ie
  if ${1:/* condition */} {
    ${2}
  } else {
    ${3}
  }
  ${0}
# for loop
snippet fo
  for ${2:i} := 0; $2 < ${1:count}; $2${3:++} {
    ${4}
  }
  ${0}
# for range loop
snippet fr
  for ${1:k}, ${2:v} := range ${3} {
    ${4}
  }
  ${0}
# make
snippet mk
  make(${1:[]string}, ${0:0})
# map
snippet mp
  map[${1:string}]${0:int}
# main()
snippet main
  func main() {
    ${1}
  }
  ${0}
# new
snippet nw
  new(${0:type})
# panic
snippet pn
  panic("${0:msg}")
# print
snippet pr
  fmt.Printf("%${1:s}\n", ${2:var})
# range
snippet rn
  range ${0}
# return
snippet rt
  return ${0}
# result
snippet rs
  result
# select
snippet sl
  select {
  case ${1:v1} := <-${2:chan1}
    ${3}
  case ${4:v2} := <-${5:chan2}
    ${6}
  default:
    ${0}
  }
# string
snippet sr
  string
# struct
snippet st
  struct ${1:name} {
    ${2:/* data */}
  }
  ${0}
# switch
snippet sw
  switch ${1:var} {
  case ${2:value1}:
    ${3}
  case ${4:value2}:
    ${5}
  default:
    ${0}
  }
snippet sp
  fmt.Sprintf("%${1:s}", ${2:var})
snippet go
  go ${1:funcName}(${0})
# goroutine anonymous function 
snippet ga
  go func(${1} ${2:type}) {
    ${3:/* code */}
  }(${0})

snippet     des
abbr        Describe("test", func() ... })
alias       Describe(
options     head
  Describe("${1}", func() {
    ${0:TARGET}
  })

snippet     con
abbr        Context("test", func() ... })
alias       Context(
options     head
  Context("${1}", func() {
    ${0:TARGET}
  })

snippet     bef
abbr        BeforeEach("test", func() ... })
alias       BeforeEach(
options     head
  BeforeEach(func() {
    ${0:TARGET}
  })

snippet     aft
abbr        AfterEach("test", func() ... })
alias       AfterEach(
options     head
  AfterEach(func() {
    ${0:TARGET}
  })

snippet     just
abbr        JustBeforeEach("test", func() ... })
alias       JustBeforeEach(
options     head
  JustBeforeEach(func() {
    ${0:TARGET}
  })

snippet     it
abbr        It("test", func() ... })
alias       It(
options     head
  It("${1}", func() {
    ${0:TARGET}
  })

snippet     Expect
abbr        Expect("test").
alias       Expect(
options     head
  Expect(${1}).${0}

snippet     To
abbr        Expect("test").To(...)
alias       To(
regexp      'Expect(.*)\.'
options     word
  To(${0})

snippet     NotTo
abbr        Expect("test").NotTo(...)
alias       NotTo(
regexp      'Expect(.*)\.'
options     word
  NotTo(${0})

snippet     ToNot
abbr        Expect("test").ToNot(...)
alias       ToNot(
regexp      'Expect(.*)\.'
options     word
  ToNot(${0})

snippet     exto
abbr        Expect("test").To(...)
options     head
  Expect(${1}).To(${0})

snippet     extn
abbr        Expect("test").ToNot(...)
options     head
  Expect(${1}).ToNot(${0})

snippet     exnt
abbr        Expect("test").NotTo(...)
options     head
  Expect(${1}).NotTo(${0})

snippet     eq
abbr        Equal(...)
alias       Equal(
regexp      '.\(To\|NotTo|\ToNot\)('
options     word
  Equal(${0})

snippet     bet
abbr        BeEquivalentTo(...)
alias       BeEquivalentTo(
regexp      '.\(To\|NotTo|\ToNot\)('
options     word
  BeEquivalentTo(${0})

snippet     merr
abbr        MatchError(...)
alias       MatchError(
regexp      '.\(To\|NotTo|\ToNot\)('
options     word
  MatchError(${0})

snippet     hlen
abbr        HaveLen(...)
alias       HaveLen(
regexp      '.\(To\|NotTo|\ToNot\)('
options     word
  HaveLen(${0})

snippet     csub
abbr        ContainSubstring(...)
alias       ContainSubstring(
regexp      '.\(To\|NotTo|\ToNot\)('
options     word
  ContainSubstring(${0})

snippet     mre
abbr        MatchRegexp(...)
alias       MatchRegexp(
regexp      '.\(To\|NotTo|\ToNot\)('
options     word
  MatchRegexp(${0})

snippet     mjson
abbr        MatchJSON(...)
alias       MatchJSON(
regexp      '.\(To\|NotTo|\ToNot\)('
options     word
  MatchJSON(${0})

snippet     cele
abbr        ContainElement(...)
alias       ContainElement(
regexp      '.\(To\|NotTo|\ToNot\)('
options     word
  ContainElement(${0})

snippet     hkey
abbr        HaveKey(...)
alias       HaveKey(
regexp      '.\(To\|NotTo|\ToNot\)('
options     word
  HaveKey(${0})

snippet     bnum
abbr        BeNumerically(...)
alias       BeNumerically(
regexp      '.\(To\|NotTo|\ToNot\)('
options     word
  BeNumerically(${0})

snippet     bato
abbr        BeAssignableToTypeOf(...)
alias       BeAssignableToTypeOf(
regexp      '.\(To\|NotTo|\ToNot\)('
options     word
  BeAssignableToTypeOf(${0})

